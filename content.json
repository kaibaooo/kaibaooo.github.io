{"meta":{"title":"Kaibao的學習札記","subtitle":"My notes","description":null,"author":"Kaibao","url":"https://kaibaooo.github.io","root":"/"},"pages":[{"title":"Tags","date":"2019-07-22T03:19:34.013Z","updated":"2018-11-09T05:33:34.000Z","comments":true,"path":"tags/index.html","permalink":"https://kaibaooo.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2019-07-22T03:19:34.006Z","updated":"2019-07-13T08:39:44.000Z","comments":true,"path":"about/index.html","permalink":"https://kaibaooo.github.io/about/index.html","excerpt":"","text":"KaibaoJust a computer science student. Education B.S., Computer Science and Information Engineering(CSIE), Expected 2021, National University of Kaohsiung, Kaohsiung National Pingtung Senior High School, Pingtung"},{"title":"Project","date":"2019-07-22T03:19:34.011Z","updated":"2018-11-09T05:33:34.000Z","comments":true,"path":"project/index.html","permalink":"https://kaibaooo.github.io/project/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-11T01:58:13.000Z","updated":"2018-11-11T02:04:44.000Z","comments":true,"path":"categories/index.html","permalink":"https://kaibaooo.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CHIP8模擬器開發-來寫程式吧","slug":"chip8emu-code","date":"2019-07-21T16:00:00.000Z","updated":"2019-07-22T12:23:23.990Z","comments":true,"path":"2019/07/22/chip8emu-code/","link":"","permalink":"https://kaibaooo.github.io/2019/07/22/chip8emu-code/","excerpt":"","text":"虛擬硬體環境建立根據第一篇文章的CHIP8硬體環境來實作，實作過程需要了解各個資料型態的大小，所以整理了下表供參考 型態 大小 範圍 char 1 byte -128 ~ 127 short 2 bytes -32768 ~ 32767 unsigned char 1 byte 0 ~ 255 unsigned short 2 bytes 0 ~ 65535 建立一個CHIP8的物件並加入基本硬體規格與參數Chip8.h class Chip8&#123;public: unsigned short opcode; unsigned char memory[4096]; unsigned char reg[16]; unsigned short I; unsigned short pc; unsigned char gfx[64 * 32]; unsigned char delay_timer; unsigned char sound_timer; unsigned short stack[16]; unsigned short sp; unsigned char key[16];&#125; 加入初始化CHIP8的functionChip8.h class Chip8&#123;public: //... void initialize();&#125; Chip8.cpp void Chip8::initialize() &#123; opcode = 0; I = 0; //Memory從0x200以後才能直接存取，所以初始化為0x200 pc = 0x200; sp = -1; drawFlag = true; delay_timer = 0; sound_timer = 0; for (int i = 0; i &lt; 4096; i++) &#123; memory[i] = 0; &#125; for (int i = 0; i &lt; 16; i++) &#123; reg[i] = 0; &#125; for (int i = 0; i &lt; 2048; i++) &#123; gfx[i] = 0; &#125; for (int i = 0; i &lt; 16; i++) &#123; stack[i] = 0; &#125; for (int i = 0; i &lt; 16; i++) &#123; key[i] = 0; &#125; //亂數種子產生器 srand(time(NULL));&#125; 讀取ROMChip8.h class Chip8&#123;public: //... void initialize();&#125; Chip8.cpp bool Chip8::loadGame(const char *filename) &#123; // 初始化CHIP8 initialize(); print(\"Load Game : %s\\n\", filename); // Load ROM from file FILE *filePtr = fopen(filename, \"rb\"); if(filePtr == NULL)&#123; printf(\"File is not found!\\n\"); return false; &#125; // 取得檔案大小，最大不能超過4096-512 // 將檔案指針移動到檔案最後方 fseek(filePtr, 0L, SEEK_END); // 透過ftell函式取得目前指針到檔案開頭共有多少byte long fileSize = ftell(filePtr); // 將指針移回到檔案開頭 fseek(filePtr, 0L, SEEK_SET); print(\"File Size : %d\\n\", fileSize); if (fileSize &gt; (4096 - 512)) &#123; print(\"File is too big\\n\"); return false; &#125; // 宣告一塊memory做為讀檔的buffer char * buffer = (char*)malloc(sizeof(char) * fileSize); // 使用fread將file指標複製到buffer中 fread(buffer, 1, fileSize, filePtr); print(\"Loading file....\\n\"); if (buffer == NULL) &#123; printf(\"Memory error\\n\"); return false; &#125; // 一個一個讀進去Chip8的memory當中 for (int i = 0; i &lt; fileSize; i++) &#123; memory[512 + i] = buffer[i]; &#125; print(\"ROM Loaded!\\n\"); return true;&#125; 實作Chip8 Cycle由於指令集的實作程式碼很長一大串，所以挑幾個比較特別的Opcode視作過程當成範例，剩下的舉一反三即可。 還記得CPU執行指令的過程嗎，必須先Fetch,Decode才能Execute和Store Fetch由於剛剛讀進來的ROM是從512(0x200)開始往下放，而每個Opcode都是2 bytes，所以先從memory讀1byte之後再將其往左推，與下一個byte做OR運算 opcode = memory[pc] &lt;&lt; 8 | memory[pc + 1]; Decode &amp; Execute00E0 - CLScase 0x00E0: for (int i = 0; i &lt; 2048; i++) &#123; gfx[i] = 0x0; &#125; //drawflag設為true表示執行完這個opcode之後要重新繪圖 drawFlag = true; // 執行結束，跳到下一個opcode pc += 2; break; 00EE - RETcase 0x000E: // 把stack最上層存放的值丟給PC pc = stack[sp]; //Stack減一層 sp--; pc += 2; break; 0x1NNN - JP addrcase 0x1NNN: pc = opcode &amp; 0x0FFF; break; 3XNN - SE Vx, byte這個opcode需存取到Vx暫存器，reg[(opcode &amp; 0x0F00) &gt;&gt; 8]opcode與0x0F00作AND運算的原因是此運算會將F位置的值保留，其餘歸零，留下我們要的值之後向右位移8bytes即為我們所要的值。舉例:38AAdecode的過程如下38AA -&gt; 0800 -&gt; 0008，此時值為8，帶入reg[8]即為我們所要的Vx case 0x3000: if (reg[(opcode &amp; 0x0F00) &gt;&gt; 8] == (opcode &amp; 0x00FF)) &#123; // 每個opcode為2bytes，加4即為跳過一個opcode pc += 4; &#125; else &#123; pc += 2; &#125; break; DXYN - DRW Vx, Vy, nibblecase 0xD000:&#123; //從opcode中取出我們所要的值 unsigned short x = reg[(opcode &amp; 0x0F00) &gt;&gt; 8]; unsigned short y = reg[(opcode &amp; 0x00F0) &gt;&gt; 4]; unsigned short height = (opcode &amp; 0x000F); unsigned short rowPixel; //將flag暫存器歸零 reg[0xF] = 0; for (int i = 0; i &lt; height; i++) &#123; //讀出I位置一列的值 rowPixel = memory[I + i]; for (int j = 0; j &lt; 8; j++) &#123; // 在列上一個一個pixel讀取 if ((rowPixel &amp; (0x80 &gt;&gt; j)) != 0) &#123; // 若要填入的像素上已有存在畫面，則判定碰撞 // 碰撞將VF設為1 if (gfx[x + j + (y + i) * 64] == 1) &#123; reg[0xF] = 1; &#125; // XOR顯示 gfx[x + j + (y + i) * 64] ^= 1; &#125; &#125; &#125; // 需更新畫面 drawFlag = true; pc += 2; break;&#125; FX33 - LD B, Vxcase 0x0033: //取得百位數後放至memory[I] memory[I] = reg[(opcode &amp; 0x0F00) &gt;&gt; 8] / 100; //取得十位數後放至memory[I + 1] memory[I + 1] = (reg[(opcode &amp; 0x0F00) &gt;&gt; 8] / 10) % 10; //取得個位數後放至memory[I + 2] memory[I + 2] = reg[(opcode &amp; 0x0F00) &gt;&gt; 8] % 10; pc += 2; break; 列舉以上Opcode的做法供參考，其餘opcode實作方法請參閱完成品Source 加入預設字符集Chip8.h class Chip8 &#123;public: unsigned char chip8_fontset[80] = &#123; 0xF0, 0x90, 0x90, 0x90, 0xF0, // 0 0x20, 0x60, 0x20, 0x20, 0x70, // 1 0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2 0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3 0x90, 0x90, 0xF0, 0x10, 0x10, // 4 0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5 0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6 0xF0, 0x10, 0x20, 0x40, 0x40, // 7 0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8 0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9 0xF0, 0x90, 0xF0, 0x90, 0x90, // A 0xE0, 0x90, 0xE0, 0x90, 0xE0, // B 0xF0, 0x80, 0x80, 0x80, 0xF0, // C 0xE0, 0x90, 0x90, 0x90, 0xE0, // D 0xF0, 0x80, 0xF0, 0x80, 0xF0, // E 0xF0, 0x80, 0xF0, 0x80, 0x80 // F &#125;;&#125; 字符對應方法 完整字符表如下表 來源http://devernay.free.fr/hacks/chip8/C8TECH10.HTM 繪圖引擎本篇範例採用的是freeglut(OpenGL)，因為筆者本身對OpenGL也不是很熟，所以就不多做解釋，用你喜歡的就可以了，當然也可以不用繪圖引擎，直接在命令列上以文字方式繪圖也行得通。 鍵盤輸入Source.cpp void controller(unsigned char key, int x, int y) &#123; if (key == '1') chip8.key[0x1] = 1; // Press X mapping to 1 else if (key == '2') chip8.key[0x2] = 1; // Press 2 mapping to 2 else if (key == '3') chip8.key[0x3] = 1; // Press 3 mapping to 3 else if (key == '4') chip8.key[0xC] = 1; // Press 4 mapping to C else if (key == 'q') chip8.key[0x4] = 1; // Press q mapping to 4 else if (key == 'w') chip8.key[0x5] = 1; // Press w mapping to 5 else if (key == 'e') chip8.key[0x6] = 1; // Press e mapping to 6 else if (key == 'r') chip8.key[0xD] = 1; // Press r mapping to D else if (key == 'a') chip8.key[0x7] = 1; // Press a mapping to 7 else if (key == 's') chip8.key[0x8] = 1; // Press s mapping to 8 else if (key == 'd') chip8.key[0x9] = 1; // Press d mapping to 9 else if (key == 'f') chip8.key[0xE] = 1; // Press f mapping to E else if (key == 'z') chip8.key[0xA] = 1; // Press z mapping to A else if (key == 'x') chip8.key[0x0] = 1; // Press x mapping to 0 else if (key == 'c') chip8.key[0xB] = 1; // Press c mapping to B else if (key == 'v') chip8.key[0xF] = 1; // Press v mapping to F else return;&#125;void controllerUP(unsigned char key, int x, int y) &#123; if (key == '1') chip8.key[0x1] = 0; // Press X mapping to 1 else if (key == '2') chip8.key[0x2] = 0; // Press 2 mapping to 2 else if (key == '3') chip8.key[0x3] = 0; // Press 3 mapping to 3 else if (key == '4') chip8.key[0xC] = 0; // Press 4 mapping to C else if (key == 'q') chip8.key[0x4] = 0; // Press q mapping to 4 else if (key == 'w') chip8.key[0x5] = 0; // Press w mapping to 5 else if (key == 'e') chip8.key[0x6] = 0; // Press e mapping to 6 else if (key == 'r') chip8.key[0xD] = 0; // Press r mapping to D else if (key == 'a') chip8.key[0x7] = 0; // Press a mapping to 7 else if (key == 's') chip8.key[0x8] = 0; // Press s mapping to 8 else if (key == 'd') chip8.key[0x9] = 0; // Press d mapping to 9 else if (key == 'f') chip8.key[0xE] = 0; // Press f mapping to E else if (key == 'z') chip8.key[0xA] = 0; // Press z mapping to A else if (key == 'x') chip8.key[0x0] = 0; // Press x mapping to 0 else if (key == 'c') chip8.key[0xB] = 0; // Press c mapping to B else if (key == 'v') chip8.key[0xF] = 0; // Press v mapping to F else return;&#125; 完成?做到這裡基本上已經完成核心了，尤其是那血尿的指令集實作，接下來要完成的部分就是繪圖的部分與CHIP8核心做連結，這裡就不多提了。Source : https://github.com/kaibaooo/Chip8_Emulator CHIP8模擬器開發系列文章 CHIP8模擬器開發-模擬器與CHIP8簡介 CHIP8模擬器開發-指令集 CHIP8模擬器開發-來寫程式吧 參考文章 Cowgod’s Chip-8 Technical Reference v1.0 CHIP-8 Wikipedia How to write an emulator (CHIP-8 interpreter) 額外資源 CHIP-8 ROMs","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"},{"name":"cplusplus","slug":"cplusplus","permalink":"https://kaibaooo.github.io/tags/cplusplus/"},{"name":"emulator","slug":"emulator","permalink":"https://kaibaooo.github.io/tags/emulator/"}]},{"title":"CHIP8模擬器開發-模擬器與CHIP8簡介","slug":"chip8emu-intro","date":"2019-07-21T16:00:00.000Z","updated":"2019-07-22T12:23:05.258Z","comments":true,"path":"2019/07/22/chip8emu-intro/","link":"","permalink":"https://kaibaooo.github.io/2019/07/22/chip8emu-intro/","excerpt":"","text":"模擬器基本概念模擬器主要是讓一台A電腦能夠模擬B電腦上執行的程式，其中B電腦是一款對於A電腦來說完全不同處理器架構的系統，例如我能夠在x86下執行ARM的程式。但畢竟是透過”模擬”出來的，與原電腦中間隔了一層模擬執行的階段，效能當然也就不比原生系統上快速。 電腦怎麼執行指令?電腦的CPU有一套屬於自己的指令集，根據架構的不同，CPU所能接受的指令集也會有所不同，如x86架構與ARM架構的處理器指令集是完全不同的，幾乎無法相容，這也就是為什麼要在電腦上玩手機遊戲需要藉由模擬器來”模擬”ARM架構的指令執行過程。電腦執行一連串的指令需要經過以下流程: Fetch : 從記憶體中取出下一個要執行的指令 Decode : 將指令解析成對應的資料格式 Execute : 執行該指令 Store : 儲存執行結果 Hello CHIP-8什麼是CHIP-8CHIP-8其實是一種程式語言，它需要執行在它專屬的模擬環境中，這套模擬環境是一個小型的系統架構，總共只有35個指令需要實作，非常適合第一次學習模擬器開發的一套系統。這一系列筆記將使用C語言開發CHIP-8模擬器。 CHIP-8 模擬環境規格Memory總共 4096 Bytes，其中前512Bytes(0x000~0x200)通常用來存放CHIP-8本身語言的interpreter(直譯器)，最末端的96Bytes(0xEA0-0xEFF) + 256Bytes(0xF00-0xFFF)前者是用來存放CallStack，後者是用來處理畫面刷新。 Registers共 16 個 8 bits registers，個別的名稱為V0, V1, V2….VF，其中VF被拿來做為flag使用，當執行加法運算時VF為CarryFlag，減法運算為BorrowFlag，繪圖運算為CollisionFlag(像素碰撞旗標) StackStack用來存放return addresses，與現行系統的概念一樣，目前設計通常以16層堆疊上限為原則。 Input輸入共有16個按鍵能使用(如下圖)，通常以2,8,4,6為上下左右，CHIP-8有三個關於鍵盤輸入的Opcode要實作，分別為某個鍵是否被按下、某個鍵是否沒被按、等待某個鍵被按下後存放至register中。 GraphicsChip-8的螢幕解析度為 64×32 pixels，螢幕色彩為Monochrome(單色)，繪製畫面到螢幕上顯示時以Sprite為單位，每個Sprite最多占15bytes的資料量，所以最大能繪製的單一大小為8x15 pixels Sound and TimerTimer有兩種第一種是Delay timer用來控制整個系統的速率，其值非零時會持續以60Hz的頻率減少1。第二種是Sound timer，主要是用來控制音效，當timer值為零時就會發出聲音，同樣是60Hz的頻率。 CHIP8模擬器開發系列文章 CHIP8模擬器開發-模擬器與CHIP8簡介 CHIP8模擬器開發-指令集 CHIP8模擬器開發-來寫程式吧","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"},{"name":"cplusplus","slug":"cplusplus","permalink":"https://kaibaooo.github.io/tags/cplusplus/"},{"name":"emulator","slug":"emulator","permalink":"https://kaibaooo.github.io/tags/emulator/"}]},{"title":"CHIP8模擬器開發-指令集","slug":"chip8emu-instruction-set","date":"2019-07-21T16:00:00.000Z","updated":"2019-07-22T12:23:13.097Z","comments":true,"path":"2019/07/22/chip8emu-instruction-set/","link":"","permalink":"https://kaibaooo.github.io/2019/07/22/chip8emu-instruction-set/","excerpt":"","text":"CHIP-8每個指令占2 Bytes並以big-endian的方式存放在記憶體當中，另外有10個額外的指令可加入，但本次筆記並沒有實作。 底下指令集的部分我也不知道為什麼心血來潮想把它翻成中文，建議還是去看原文版可能比較好懂啦(? NNN: 記憶體位址NN、N: 8bits或4bits的常數X and Y: register的名稱(0 ~ F)I: Index register 指令集1. 0NNN - SYS addr已不使用，Jump到某個Machine code程序中 2. 00E0 - CLS清除畫面實作方法: 請依據繪圖引擎不同自行設計 3. 00EE - RETReturn from a subroutine實作方法: 將Stack最上層的address放到ProgramCounter裡，並將StackPointer減少一層 4. 1NNN - JP addr跳到NNN這個address執行實作方法: ProgramCounter &lt;= NNN 5. 2NNN - CALL addr呼叫NNN位址中的子程序實作方法: 將StackPointer增加1，並把目前的ProgramCounter放到Stack中，最後把ProgramCounter更改為NNN 6. 3XNN - SE Vx, byteif Vx = kk, 跳過下一個指令實作方法: 比較Vx占存器所儲存的值是否與常數NN相同，如果結果為真，就跳過一次Opcode 7. 4XNN - SNE Vx, byteif Vx != kk, 跳過下一個指令實作方法: 比較Vx占存器所儲存的值是否與常數NN相異，如果結果為真，就跳過一次Opcode 8. 5XY0 - SE Vx, Vyif Vx = Vy, 跳過下一個指令實作方法: 比較Vx占存器所儲存的值是否與Vy占存器所儲存的值相同，如果結果為真，就跳過一次Opcode 9. 6XNN - LD Vx, byte將Vx的值設為NN實作方法: Vx &lt;= NN 10. 7XNN - ADD Vx, byteVx的值加上NN之後，再放到Vx中實作方法: Vx = Vx + NN 11. 8XY0 - LD Vx, VyVy的值放到Vx實作方法: Vx = Vy 12. 8XY1 - OR Vx, VyVx與Vy的每個bit做OR位元運算實作方法: Vx = Vx | Vy 13. 8XY2 - AND Vx, VyVx與Vy的每個bit做AND位元運算實作方法: Vx = Vx &amp; Vy 14. 8XY3 - XOR Vx, VyVx與Vy的每個bit做XOR位元運算實作方法: Vx = Vx ^ Vy 15. 8XY4 - ADD Vx, Vy將Vx的值設為Vx+Vy，若相加數值超過255則將VF(CarryFlag)設為1實作方法: Vx = Vx + Vy, 若相加結果無法完整放於8bits中，則將VF設為1，並把低位元的8bits放到Vx中 16. 8XY5 - SUB Vx, Vy將Vx的值設為Vx-Vy，若Vx&gt;Vy則將VF設為1，否則為0實作方法: Vx = Vx - Vy, 若Vx&gt;Vy則將VF的值設為1，否則為0，並將相減結果存放至Vx中 17. 8XY6 - SHR Vx {, Vy}將Vx最大位元的數值放到VF中，並將Vx除以2實作方法: 將Vx最大位元放置VF中後，把Vx向右位移1bit 18. 8XY7 - SUBN Vx, Vy將Vx的值設為Vy-Vx，若Vy&gt;Vx則將VF設為1，否則為0實作方法: Vx = Vy - Vx, 若Vy&gt;Vx則將VF的值設為1，否則為0，並將相減結果存放至Vx中 19. 8XYE - SHL Vx {, Vy}將Vx最大位元的數值放到VF中，並將Vx乘以2實作方法: 將Vx最大位元放置VF中後，把Vx向右位移1bit 20. 9xy0 - SNE Vx, Vyif Vx != Vy 跳過下一個指令實作方法: 若Vx != Vy，則跳過一次Opcode 21. ANNN - LD I, addr將I的值設為NNN實作方法: 恩…如上所述 22. BNNN - JP V0, addr程式跳至NNN+V0的位置執行實作方法: 將ProgramCounter的值設為NNN再加上暫存器V0的值 23. CXNN - RND Vx, byte隨機產生一個8bits的數字與常數NN做AND運算，並值放置Vx中實作方法: 呼叫C語言中的亂數產生器產生0~255的數字，並透過8XY2的概念來執行AND運算，運算結果放到Vx的值中 24. DXYN - DRW Vx, Vy, nibble在(Vx, Vy)的座標上繪製一個從I所儲存的位址開始n bytes的sprite，若畫面有任何已存在的pixel被修改，則將VF設為1(CollisionFlag)實作方法: 從I所儲存的位址開始以byte為單位繪製畫面，每個pixel繪製之前都須與現有畫面上的pixel做XOR運算(參閱8XY3 opcode)，若結果為真，則將VF值改為1否則為0。詳細繪製方法請參閱繪圖引擎的相關文件。 25. Ex9E - SKP Vx若存放在Vx的KeyCode等於目前所按下的按鍵，則跳過下個Opcode實作方法: 檢查目前按下的KeyCode是否等於Vx的值，若兩值相等則將ProgramCounter加2 26. EXA1 - SKNP Vx若存放在Vx的KeyCode目前沒有被按下，則跳過下個Opcode實作方法: 檢查Vx目前的KeyCode是否處於非按下的情況，若為非按下的情況則將ProgramCounter加2 27. FX07 - LD Vx, DTVx的值設為目前的Delay Time 28. Fx0A - LD Vx, K等待按鍵輸入，當任一按鍵觸發時將其KeyCode存放至Vx中實作方法: 這是一個blocking的Opcode，會等待任一按鍵觸發之後將其值存放至Vx當中 29. FX15 - LD DT, Vx將目前Delay Timer的值設為Vx所存放的值 30. FX18 - LD ST, Vx將目前Sound Timer的值設為Vx所存放的值 31. FX1E - ADD I, Vx將I與Vx的值相加之後存放至I當中 32. FX29 - LD F, Vx將Vx的值對應到正確字型記憶體位置後存放到I實作方法: 第一次看到這個有點不解，舉個範例來解釋比較清楚，由於我們存放預設字型的位置是0x0000~0x0050，每個字各占5 bytes大小，假設Vx暫存器的值是3，那麼它所對應的字型3記憶體位置應為0x000F開始，所以將0x000F放至I當中。簡單來說因為每個字占5bytes而且又是從0開始，所以將Vx當中的值乘上5後即可存放至I。 33. FX33 - LD B, Vx將Vx中的值轉換成BCD表示法，並將結果分別存放至記憶體位址I(百位數字),I+1(十位數字),I+2(個位數)實作方法: BCD轉換不多談，來說明一下I存放的方法，由於I存放的是記憶體位址，所以必須藉由memory[I]這樣的存取方式存放值到記憶體當中。 34. FX55 - LD [I], Vx俗稱的register dump，把特定範圍register所存放的值複製一份到從I開始的連續記憶體當中實作方法: V0~Vx依序將值複製到I, I+1, I+2….V+x當中 35. FX65 - LD Vx, [I]從I開始的memory當中依序取出值存放到register當中實作方法: I, I+1, I+2….V+x依序將值複製到V0~Vx當中 CHIP8模擬器開發系列文章 CHIP8模擬器開發-模擬器與CHIP8簡介 CHIP8模擬器開發-指令集 CHIP8模擬器開發-來寫程式吧","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"},{"name":"cplusplus","slug":"cplusplus","permalink":"https://kaibaooo.github.io/tags/cplusplus/"},{"name":"emulator","slug":"emulator","permalink":"https://kaibaooo.github.io/tags/emulator/"}]},{"title":"在Visual Studio 2019上使用OpenCV","slug":"學習筆記/opencv-vs2019","date":"2019-07-17T16:00:00.000Z","updated":"2019-07-17T16:21:02.000Z","comments":true,"path":"2019/07/18/學習筆記/opencv-vs2019/","link":"","permalink":"https://kaibaooo.github.io/2019/07/18/學習筆記/opencv-vs2019/","excerpt":"","text":"安裝OpenCV首先，到OpenCV的官網下載最新的版本，在此示範的版本為Windows 3.4.6 下載完成後點擊安裝，建議路徑選擇在C槽底下，或是自己方便放Library的資料夾底下，確認後把路徑記下來然後解壓縮 設定環境變數，在Path中加入C:\\opencv\\build\\x64\\vc15\\bin 建立專案在VS2019中開啟一個C++的空專案 開啟完成後，對專案點右鍵&gt;屬性 設定懶人包若OpenCV的路徑有做更動，請自行修改為正確路徑 組態:Debug 平台:x64 VC++目錄&gt;Include目錄 : 加入C:\\opencv\\build\\include VC++目錄&gt;程式庫目錄 : 加入C:\\opencv\\build\\x64\\vc15\\lib 連結器&gt;其他相依性 : 加入opencv_world346d.lib 設定完成的圖 此處的opencv_world346d.lib可能會依據安裝的OpenCV版本不同而有更動，請至C:\\opencv\\build\\x64\\vc15\\lib中做確認帶有d字尾的.lib檔為Debug組態使用，未帶d字尾的.lib則為Release組態使用，請依據您的組態彈性調整，但請不要兩個都加進去設定中，執行程式時可能會出現兩個畫面 Hello OpenCV在來源檔案中新增一個cpp檔 然後打上範例程式注意程式中第六行的YOUR_IMG_PATH的地方要換成你自己要顯示的圖片路徑，記得路徑的\\要換成\\\\ #include&lt;opencv2/opencv.hpp&gt;using namespace cv;int main() &#123; Mat img = imread(\"YOUR_IMG_PATH\", -1); if (img.empty()) return -1; namedWindow(\"HelloCV\", WINDOW_AUTOSIZE); imshow(\"HelloCV\", img); waitKey(0); destroyWindow(\"HelloCV\"); return 0;&#125; 確認組態為Debug、x64之後即可編譯執行 執行結果範例","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://kaibaooo.github.io/tags/OpenCV/"}]},{"title":"如何正確安裝VSCode","slug":"vscode-installation","date":"2019-07-12T16:00:00.000Z","updated":"2019-07-18T06:26:44.000Z","comments":true,"path":"2019/07/13/vscode-installation/","link":"","permalink":"https://kaibaooo.github.io/2019/07/13/vscode-installation/","excerpt":"","text":"如何正確安裝VSCode這一兩年來，Visual Studio Code透過原生支援Git與豐富的擴充元件生態系，且背後又是微軟爸爸(?，在編輯器大戰中脫穎而出，成為最受各大開發者喜愛的文字編輯器，但許多人正要踏入VSCode的懷抱時，安裝過程總容易少了幾個步驟，所以想透過這篇文章來記錄下VSCode安裝過程該注意的選項。 下載Visual Studio Codehttps://code.visualstudio.com/ 安裝過程前段安裝過程不太需要動，下一步即可，最重要的是這一步 右鍵選單 將[以Code開啟]動作加入Windows檔案總管檔案的操作功能表中 將[以Code開啟]動作加入Windows檔案總管目錄的操作功能表中 因為VSCode的編輯環境通常以一個工作區(資料夾)為單位，會自動為各個資料夾加入獨立的設定檔，所以將這兩個選項勾起來可以方便以後開啟資料夾快速編輯，建議勾選 支援附檔名 針對支援的檔案類型將Code註冊為編輯器VSCode支援大部分的程式檔與設定檔，會針對各個不同的副檔名更換該檔案的圖示，建議勾選 從terminal中執行VSCode 加入PATH中 VSCode支援從Terminal中執行，對於常用terminal工作的開發者相當方便，若不常使用terminal可以取消勾選 以上是我認為VSCode安裝過程中比較重要的設定，許多人可能會忽略，造成開發過程中覺得有那麼一點不便。","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"},{"name":"VSCode","slug":"VSCode","permalink":"https://kaibaooo.github.io/tags/VSCode/"}]},{"title":"Python資料科學學習筆記-UniversalFunctions","slug":"學習筆記/datascience-note-numpy-universalfunctions","date":"2019-07-10T16:00:00.000Z","updated":"2019-07-13T08:23:46.000Z","comments":true,"path":"2019/07/11/學習筆記/datascience-note-numpy-universalfunctions/","link":"","permalink":"https://kaibaooo.github.io/2019/07/11/學習筆記/datascience-note-numpy-universalfunctions/","excerpt":"","text":"本篇文章為筆者的學習筆記，參考書籍為歐萊禮/Python資料科學學習手冊/Jake VanderPlas/何敏煌(譯)https://www.books.com.tw/products/0010774364 基本運算子 運算子 對應的ufunc + np.add - np.subtract * np.multiply / np.divide // np.floor_divide ** np.power % np.mod abs np.absolute 三角函數 函數 對應的ufunc $π$ np.pi $sin$ np.sin $cos$ np.cos $tan$ np.tan $arcsin$ np.arcsin $arccos$ np.arccos $arctan$ np.arctan $log_e$ np.log $log_2$ np.log2 $log_{10}$ np.log10 $e^x$ np.exp(x) 更精準的$log_e$ np.log1p 更精準的$e^x$ np.expm1(x) ufunc透過out設定輸出位置x = np.arange(5)y = np.empty(5)np.multiply(x,2,out=y)# [0, 10, 20, 30, 40] x = np.zeros(10)np.power(2,x,out=y[::2])# [1, 0, 2, 0, 4, 0, 7, 0, 16, 0] 聚合方法從頭跑到尾 取得最終結果x = np.arange(1, 6)np.add.reduce(x) 從頭跑到尾 紀錄一路上的輸出x = np.arange(1, 6)np.add.accumulate(x) 外積x = np.arange(1, 6)np.add.outer(x, x) Result: [ 2, 3, 4, 5, 6],[ 3, 4, 5, 6, 7],[ 4, 5, 6, 7, 8],[ 5, 6, 7, 8, 9],[ 6, 7, 8, 9, 10] x = np.arange(1, 6)np.multiply.outer(x, x) Result: [ 1, 2, 3, 4, 5],[ 2, 4, 6, 8, 10],[ 3, 6, 9, 12, 15],[ 4, 8, 12, 16, 20],[ 5, 10, 15, 20, 25] 加總、最大、最小使用到numpy的陣列時，建議使用numpy提供的function big_array = np.random.rand(1000000)array_2d = np.random.random((3,4)) 加總sum(big_array) #原生Python版本 np.sum(big_array) #numpy版本 最大值#原生Python版本 max(big_array) #numpy版本 np.max(big_array) #numpy陣列版本 big_array.max() #取得各欄最大值 np.max(array_2d, axix=0) #取得各列最大值 np.max(array_2d, axix=1) 最小值min(big_array) # 原生Python版本 np.min(big_array) # numpy版本 big_array.min() # numpy陣列版本 np.min(array_2d, axix=0) # 取得各欄最小值 np.min(array_2d, axix=1) # 取得各列最小值 axis用來指定陣列中要被收合起來的那個維度，而不是要被傳回的那個 函式 Nan-Safe版本 說明 np.sum np.nansum 所有元素加總 np.prod np.nanprod 所有元素乘積 np.mean np.nanmean 所有元素平均值 np.std np.nanstd 計算標準差 np.var np.nanvar 計算變異數 np.min np.nanmin 計算最小值 np.max np.nanmax 計算最大值 np.argmin np.nanargmin 找出最小值的索引 np.argmax np.nanargmax 找出最大值的索引 np.median np.nanmedian 找出中位數 np.percentile np.nanpercentile 計算元素的排名統計(百分位數) np.any N/A 當陣列中任一值為True或非0時傳回True np.all N/A 當陣列中所有值為True或非0時傳回True Broadcasting概念 最簡單概念是a = np.arange(1,4)a + 5 Result : [5, 6, 7] 數值5就如同被拉長成一個陣列[5, 5, 5]，然後再計算 再更進一步M = np.ones((3, 3))M + a Result : [[1, 2, 3], [1, 2, 3], [1, 2, 3]] 複雜一點a = np.arange(3)b = np.arange(3)[:, newaxis]a + b Result : [[0, 1, 2], [1, 2, 3], [2, 3, 4]] 圖片來源:https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html 比較運算子 運算子 ufunc == np.equal != np.not_equal &lt; np.less &lt;= np.less_equal &gt; np.greater &gt;= np.greater_equal x = np.arange(1, 6)x &lt; 3 Result:array([ True, True, False, False, False]) 計算元素數量x = np.arange(10) 計算小於6的數量np.count_nonzero(x &lt; 6) 計算小於6的總和np.sum(x &lt; 6) 是否有任一值大於8np.any(x &gt; 8) 是否全都等於10np.all(x &gt; 10) 邏輯運算元 運算子 ufunc &amp; np.bitwise_and | np.bitwise_or ^ np.bitwise_xor ~ np.bitwise_not 布林遮罩x = np.array([[5,0,3,3], [7,9,3,5], [2,4,7,6]])x_mask = x &lt; 5x[x_mask] Fancy索引:更強的索引機制傳入索引陣列取值x = np.random.randint(10, size=100)idx = [3,7,5]x[idx] 根據索引陣列形狀產生陣列x = np.random.randint(10, size=100)idx = np.array([[3,7], [5,9]])x[idx] 多維陣列索引X = np.arange(12).reshape((3,4))row = np.array([0, 1, 2])col = np.array([2, 1, 3])X[row, col] 搭配切片X = np.arange(12).reshape((3,4))X[1:, [2,0,1]] 搭配遮罩mask = np.array([1,0,1,0], dtype=np.bool)X[row[:, np.newaxis], mask]","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"},{"name":"Python","slug":"Python","permalink":"https://kaibaooo.github.io/tags/Python/"}]},{"title":"Python資料科學學習筆記-Numpy陣列基礎操作","slug":"學習筆記/datascience-note-numpy-array-operations","date":"2019-07-07T16:00:00.000Z","updated":"2019-07-13T08:23:58.000Z","comments":true,"path":"2019/07/08/學習筆記/datascience-note-numpy-array-operations/","link":"","permalink":"https://kaibaooo.github.io/2019/07/08/學習筆記/datascience-note-numpy-array-operations/","excerpt":"","text":"本篇文章為筆者的學習筆記，參考書籍為歐萊禮/Python資料科學學習手冊/Jake VanderPlas/何敏煌(譯)https://www.books.com.tw/products/0010774364 建立陣列的各種方式內容全為0的陣列np.zeros(10, dtype=np.int) array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 內容全為1的陣列np.ones((3,5), dtype=np.int) array([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) 填滿同一元素np.full((3,5), 3.14, dtype=np.float) array([[3.14, 3.14, 3.14, 3.14, 3.14], [3.14, 3.14, 3.14, 3.14, 3.14], [3.14, 3.14, 3.14, 3.14, 3.14]]) 依序填滿的矩陣np.arange(0, 10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 產生特定間隔數的陣列np.linspace(0,1,5) array([0. , 0.25, 0.5 , 0.75, 1. ]) 隨機陣列np.random.random((3,3)) array([[0.67008401, 0.66344056, 0.66557893], [0.211046 , 0.63600443, 0.51327634], [0.75571898, 0.94306233, 0.6197861 ]]) 隨機常態分佈陣列np.random.normal(0,1(3,3)) array([[ 1.04213031, 0.77624605, -0.42446014], [ 0.07087546, 0.81222484, -0.52451604], [ 1.98723693, -0.91196085, 0.78381324]]) 隨機範圍整數矩陣np.random.randint(0,10, 10) array([9, 7, 5, 2, 0, 3, 9, 3, 3, 4]) 單位矩陣np.eye(5) array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.]]) 未初始化矩陣np.empty(5) array([1., 1., 1., 1., 1.]) 陣列屬性x = np.random.randint(0,10,(2,3)) 陣列維度 : x.ndim =&gt; 2 各維度大小 : x.shape =&gt; (2, 3) 整個陣列總大小 : x.size =&gt; 6 陣列的資料型態 : x.dtype =&gt; dtype(‘int32’) 陣列元素的位元組大小 : x.itemsize =&gt; 4 (Bytes) 陣列總位元組大小 : x.nbytes =&gt; 24 (Bytes) 陣列操作x2 = np.array([[12, 5, 6, 1], [ 7, 6, 8, 8], [ 1, 6, 7, 7]]) 取得2列3欄 : x2[:2, :3] array([[12, 5, 6], [ 7, 6, 8]]) 取得所有偶數欄 : x2[:3, ::2] array([[12, 6], [ 7, 8], [ 1, 7]]) 取得陣列的第1列元素 : x2[:, 0] array([12, 7, 1]) 取得陣列的第1欄元素 : x2[0, :] array([12, 5, 6, 1]) 所有陣列操作都是藉由參考來執行，會改變原變數的值若不想改變原變數的值，則藉由np.array.copy()來執行 陣列變形x3 = np.arange(1,10) 將x3更改為3x3矩陣 : x3.reshape(3,3) 透過x3建立列向量(reshape) : x3.reshap(3, 1) 透過x3建立列向量(newaxis) : x3[np.newaxis, :] 透過x3建立欄向量(reshape) : x3.reshap(1, 3) 透過x3建立欄向量(newaxis) : x3[:, np.newaxis] 陣列的合併 np.concatenate, np.vstack(垂直堆疊), np.hstack(水平堆疊), np.dstack(3D) x = np.array([1,2,3])y = np.array([4,5,6])z = np.array([[99], [99]])grid = np.array([[1,2,3], [4,5,6]]) 合併陣列np.concatenate([x, y]) [1,2,3,4,5,6] 合併陣列np.concatenate(grid, grid) [[1,2,3], [4,5,6], [1,2,3], [4,5,6]] 合併陣列np.concatenate(grid, grid, axis=1) [[1,2,3,1,2,3], [4,5,6,4,5,6]] 垂直堆疊合併np.vstack(x, grid) [[1, 2, 3], [1, 2, 3], [4, 5, 6]] 水平堆疊合併np.hstack([z, grid]) [[99, 1, 2, 3], [99, 4, 5, 6]] 陣列的分割 np.split, np.vsplit(垂直分割), np.hsplit(水平分割) x = [1,2,3,99,99,3,2,1]grid = [[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]] 分割陣列np.split(x, [3,5]) [1,2,3], [99,99], [3,2,1] 垂直分割陣列np.vsplit(grid, [2]) upper, lower = np.vsplit(grid, [2])upper = [[0, 1, 2, 3], [4, 5, 6, 7]]lower = [[ 8, 9, 10, 11], [12, 13, 14, 15]] 水平分割陣列np.hvsplit(grid, [2]) left, right = np.hsplit(grid, [2])left = [[ 0 1] [ 4 5] [ 8 9] [12 13]][[0, 1, 2, 3], [4, 5, 6, 7]]right = [[ 2 3] [ 6 7] [10 11] [14 15]][[ 8, 9, 10, 11], [12, 13, 14, 15]]","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"},{"name":"Python","slug":"Python","permalink":"https://kaibaooo.github.io/tags/Python/"}]},{"title":"使用margin-top該注意的坑","slug":"collapsing-margin-solution","date":"2019-04-21T16:00:00.000Z","updated":"2019-07-18T06:29:48.000Z","comments":true,"path":"2019/04/22/collapsing-margin-solution/","link":"","permalink":"https://kaibaooo.github.io/2019/04/22/collapsing-margin-solution/","excerpt":"","text":"問題最近在切網頁版面的時候，突然很常遇到div無法正確對本身parent元素對齊的狀況，到StackOverFlow上面查了一下，發現這個問題叫做Collapsing margins 問題發生原因引用MDN上的說明 Adjacent siblingsThe margins of adjacent siblings are collapsed (except when the latter sibling needs to be cleared past floats).Parent and first/last childIf there is no border, padding, inline part, block formatting context created, or clearance to separate the margin-top of a block from the margin-top of its first child block; or no border, padding, inline content, height, min-height, or max-height to separate the margin-bottom of a block from the margin-bottom of its last child, then those margins collapse. The collapsed margin ends up outside the parent.Empty blocksIf there is no border, padding, inline content, height, or min-height to separate a block’s margin-top from its margin-bottom, then its top and bottom margins collapse. 簡單來說就是 父元素與子元素都是block，且子元素沒有float屬性 父元素沒有border、padding、overflow屬性將內外隔開，以至於margin-top和margin-bottom重疊 解決方法1. 子元素加上float屬性 See the Pen margin collapse solution4 by Kai-Lun Huang (@kaibaooo) on CodePen. 2. 子元素更改為inline-block See the Pen margin collapse solution3 by Kai-Lun Huang (@kaibaooo) on CodePen. 3. 父元素加上border See the Pen margin collapse solution2 by Kai-Lun Huang (@kaibaooo) on CodePen. 4. 父元素加上padding See the Pen margin collapse solution1 by Kai-Lun Huang (@kaibaooo) on CodePen. 參考資料MDN - Mastering margin collapsing","categories":[],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://kaibaooo.github.io/tags/frontend/"}]},{"title":"喔不！是CORS","slug":"cors-solution","date":"2019-03-01T16:00:00.000Z","updated":"2019-07-18T06:29:32.000Z","comments":true,"path":"2019/03/02/cors-solution/","link":"","permalink":"https://kaibaooo.github.io/2019/03/02/cors-solution/","excerpt":"","text":"喔不！是CORS前言看到JS地下城5F題目的時候，心裡想「噢，這不就AJAX嗎 簡單!」，到了實際上要抓資料的時候，發現並沒有那麼容易，一開始是透過ES6內建的fetch()來抓資料，但跳出了這個訊息 問題所在這個訊息說明了行政院環保署的Server端不提供CORS(Cross-Origin Resource Sharing)存取。 這時內心又會有另一個問題，CORS是甚麼? 這裡引用一段MDN上的說明 Cross-Origin Resource Sharing (CORS) is a mechanism that uses additional HTTP headers to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. A web application executes a cross-origin HTTP request when it requests a resource that has a different origin (domain, protocol, and port) than its own origin. 簡單來說，XMLHttpRequest和Fetch API兩種AJAX的存取方式都需要遵守same-origin policy，也就是在前端呼叫另一個網域的資源需要在同一個域名下才行，例如fetch()不能在 http://127.0.0.1/ 底下呼叫 https://www.google.com/ 的資源。雖然這兩個AJAX的呼叫方法都要遵守same-origin policy，但可以透過在伺服器上設定加入回應Access-Control-Allow-Origin的header，讓其他網域能夠存取你伺服器上的資源。(氣象局API不能直接存取的原因就是少了這個header) 解決方法上面有提到前端的AJAX不能直接使用GET存與資料，但後端可以，所以我們的解決方法是透過自己寫的代理server來取得氣象局的AQI資料後，再自己透過HTTP將取得的資料回傳回來。 這裡使用了request來GET網頁上的資料，並使用express透過HTTP回傳回來 const request = require('request');var express = require('express');var app = express();app.get(/^\\/corskiller\\/.*/, async function (req, res) &#123; const targetURL = req.originalUrl.slice(12); await request(targetURL, async function (error, response, body) &#123; await res.setHeader('Access-Control-Allow-Origin', '*') await res.setHeader('Content-Type', 'application/json'); await res.send(body); &#125;);&#125;);app.listen(3000, function () &#123; console.log('Waiting for GET');&#125;); 架好之後只要透過正常的AJAX抓取https://localhost:3000/corskiller/&lt;API URL&gt;，就能獲得該API上的資料囉~ 最重要的Access-Control-Allow-Origin設定伺服器的可以允許哪些網域來存取，在這裡設為無限制 await res.setHeader('Access-Control-Allow-Origin', '*') 其他設定參數如下 不限制 Access-Control-Allow-Origin : * 特定域名才能存取 Access-Control-Allow-Origin : domain 不啟用 Access-Control-Allow-Origin : null 之後的事情弄了這麼一大坨之後，開開心心部屬到GCP上面，結果發現域名沒有SSL憑證，不能直接存取，覺得心好累，覺得heroku會休眠有點小討厭，所以就弄個Google Script來處理這個問題了(:з」∠) 參考資料CORS -https://developer.mozilla.org/en-US/docs/Web/HTTP/CORSAccess-Control-Allow-Origin -https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Server-Side_Access_Control","categories":[],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://kaibaooo.github.io/tags/frontend/"},{"name":"學習筆記","slug":"學習筆記","permalink":"https://kaibaooo.github.io/tags/學習筆記/"}]},{"title":"UVA10591-Happy Number解法","slug":"uva10591","date":"2018-11-10T16:00:00.000Z","updated":"2019-07-18T06:21:34.000Z","comments":true,"path":"2018/11/11/uva10591/","link":"","permalink":"https://kaibaooo.github.io/2018/11/11/uva10591/","excerpt":"敘述7 is a Happy number since 7 → 49 → 97 → 130 → 10 → 14 is an Unhappy number since 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 輸入說明一個正整數 輸出說明輸出是否為Happy Number Solution將執行過的數字記錄下來record[]，每次平方後做一次查表，看看有沒有重複做過的數字，如果有重複數字就不是HappyNumber。 將一路上執行過的數字紀錄下來，每次跑下一個數字之前先從頭檢查一遍是否重複，如果有重複數字的話，則為UnhappyNumeber","text":"敘述7 is a Happy number since 7 → 49 → 97 → 130 → 10 → 14 is an Unhappy number since 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 輸入說明一個正整數 輸出說明輸出是否為Happy Number Solution將執行過的數字記錄下來record[]，每次平方後做一次查表，看看有沒有重複做過的數字，如果有重複數字就不是HappyNumber。 將一路上執行過的數字紀錄下來，每次跑下一個數字之前先從頭檢查一遍是否重複，如果有重複數字的話，則為UnhappyNumeber 為什麼不檢查到回到自己?在測資為數字2的時候，2-&gt;4-&gt;16….，你會發現2是不會回到自己的!!!因為4會一直循環，不會回到二，而造成程式陷入無限迴圈 #include&lt;stdio.h&gt;int deal(int k) &#123; int sum = 0; while (k) &#123; sum += (k % 10) * (k % 10); k /= 10; &#125; return sum;&#125;int main() &#123; int cases = 0; int record[700]; int temp = 0; scanf(\"%d\", &amp;cases); for (int j = 1; j &lt;= cases;j++) &#123; int count = 0,flag = 0; int num = 0; scanf(\"%d\", &amp;num); temp = num; while (num != 1) &#123; record[count] = num; num = deal(num); for (int idx = 0; idx &lt;= count; idx++) &#123; if (record[idx] == num) &#123; flag = 1; break; &#125; &#125; if (flag) &#123; printf(\"Case #%d: %d is an Unhappy number.\\n\",j, temp); break; &#125; count++; &#125; if(num == 1) printf(\"Case #%d: %d is a Happy number.\\n\",j, temp); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"https://kaibaooo.github.io/tags/Cplusplus/"},{"name":"C","slug":"C","permalink":"https://kaibaooo.github.io/tags/C/"}]},{"title":"UVA11292-Dragon of Loowater解法","slug":"uva11292","date":"2018-11-10T16:00:00.000Z","updated":"2019-07-18T06:21:36.000Z","comments":true,"path":"2018/11/11/uva11292/","link":"","permalink":"https://kaibaooo.github.io/2018/11/11/uva11292/","excerpt":"敘述有個王國遭受龍群的侵襲，需要聘請騎士把龍全部消滅掉，否則王國會滅亡。 騎士身高(int)必須大於等於龍的頭數(int)才能殺掉龍，每聘用一位騎士需要花費其身高的金幣數(e.g 身高為3的騎士，需要花費3金幣)，每位騎士只能殺死一條龍。 輸入說明每行輸入兩個整數n,m，分別代表龍群的數量以及騎士的數量，接下來n行資料分別為龍的頭數，接續下去的m行資料為騎士的身高 輸出說明輸出最小花費金幣數","text":"敘述有個王國遭受龍群的侵襲，需要聘請騎士把龍全部消滅掉，否則王國會滅亡。 騎士身高(int)必須大於等於龍的頭數(int)才能殺掉龍，每聘用一位騎士需要花費其身高的金幣數(e.g 身高為3的騎士，需要花費3金幣)，每位騎士只能殺死一條龍。 輸入說明每行輸入兩個整數n,m，分別代表龍群的數量以及騎士的數量，接下來n行資料分別為龍的頭數，接續下去的m行資料為騎士的身高 輸出說明輸出最小花費金幣數 Solution題目條件看似很難，需要盡可能殺掉完所有的龍，又要花費最小，但其實只要將資料排序後，一一對應處理，就能找出最小花費了。 假設有4條龍和5位騎士，對應數值如下 龍 : 5 4 3 2騎士 : 1 7 3 5 6 將資料由小到大做排列之後 龍 : 2 3 4 5騎士 : 1 3 5 6 7 第一位騎士 1 vs 第一條龍 2 (無法獲勝，即聘用下一位騎士)第二位騎士 3 vs 第一條龍 2 (獲勝，總花費為3)第三位騎士 5 vs 第二條龍 3 (獲勝，總花費為3+5)第四位騎士 6 vs 第三條龍 4 (獲勝，總花費為3+5+6)第五位騎士 7 vs 第四條龍 5 (獲勝，總花費為3+5+6+7) 求得最小花費為21 程式執行到騎士用完或是龍被殺光時即結束當龍被殺光時輸出最小花費當騎士用完時輸出Loowater is doomed! Code#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;int main() &#123; int n, m; int i, j; int sumN = 0; while (scanf(\"%d %d\", &amp;n, &amp;m)) &#123; if (n == 0 &amp;&amp; m == 0) break; int *numN = (int*)malloc(sizeof(int) * n); int *numM = (int*)malloc(sizeof(int) * m); for (i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;numN[i]); sumN += numN[i]; &#125; for (j = 0; j &lt; m; j++) &#123; scanf(\"%d\", &amp;numM[j]); &#125; std::sort(numN, numN + n); std::sort(numM, numM + m); int sum = 0; for (i = 0,j = 0; i &lt; n &amp;&amp; j &lt; m;) &#123; if (numM[j] &gt;= numN[i]) &#123; sum += numM[j]; i++; j++; &#125; else &#123; j++; &#125; &#125; if (sum &gt;= sumN) printf(\"%d\\n\", sum); else printf(\"Loowater is doomed!\\n\"); sumN = 0; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"https://kaibaooo.github.io/tags/Cplusplus/"},{"name":"C","slug":"C","permalink":"https://kaibaooo.github.io/tags/C/"}]},{"title":"UVA10189-Minesweeper解法","slug":"uva10189","date":"2018-11-10T16:00:00.000Z","updated":"2019-07-18T06:21:38.000Z","comments":true,"path":"2018/11/11/uva10189/","link":"","permalink":"https://kaibaooo.github.io/2018/11/11/uva10189/","excerpt":"敘述計算周遭九宮格的地雷數 輸入說明輸入兩整數n,m，分別為地雷區的row和column接下來n行輸入地雷的位置，輸入 * 代表有地雷，輸入 . 代表無地雷 輸出說明輸出如Windows踩地雷那樣的周圍九宮格地雷數 Solution雖然題目定義最高為100x100的大小，但為了讓邊界處理簡單些，我們宣告102x102大小的二維陣列來處理","text":"敘述計算周遭九宮格的地雷數 輸入說明輸入兩整數n,m，分別為地雷區的row和column接下來n行輸入地雷的位置，輸入 * 代表有地雷，輸入 . 代表無地雷 輸出說明輸出如Windows踩地雷那樣的周圍九宮格地雷數 Solution雖然題目定義最高為100x100的大小，但為了讓邊界處理簡單些，我們宣告102x102大小的二維陣列來處理 以下一個二維陣列 X X X X X X X X O O O O O X X O O O O O X X O O O O O X X O O O O O X X O O O O O X X X X X X X X 雖然這是個7x7的陣列，但我們只用中間5x5的區域(O部分)，當地雷在角落或邊界的時，只宣告5x5的陣列的話，那麼周圍8格會有部分超出邊界的情況，如果沒有處理好，會有陣列違規存取的情況發生，所以為了將問題簡單化，採用較大陣列的方式處理 周圍地雷數量判斷好之後，會類似下圖這樣: 1 1 1 0 0 0 0 1 * 1 0 0 0 0 1 2 2 1 0 0 0 0 1 * 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 但我們只取中間5x5的部分實際上輸出: * 1 0 0 0 2 2 1 0 0 1 * 1 0 0 1 1 1 0 0 0 0 0 0 0 這樣就完成了5x5不用做邊界處理的MineSweeper了~ Code#include&lt;stdio.h&gt;int main() &#123; int n, m; int count = 1; char tmp; while (scanf(\"%d %d\", &amp;n, &amp;m)) &#123; if (n == 0 &amp;&amp; m == 0) break; else if(count&gt;1) printf(\"\\n\"); int map[102][102] = &#123; 0 &#125;; int danZone[102][102] = &#123; 0 &#125;; for (int i = 1; i &lt;= n; i++) &#123; getchar(); for (int j = 1; j &lt;= m; j++) &#123; scanf(\"%c\", &amp;tmp); if (tmp == '*') &#123; map[i][j] = 1; &#125; else map[i][j] = 0; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (map[i][j] == 1) &#123; for (int a = -1; a &lt;= 1; a++) for (int b = -1; b &lt;= 1; b++) &#123; if (map[i + a][j + b] != 1) danZone[i + a][j + b]++; &#125; &#125; &#125; &#125; printf(\"Field #%d:\\n\", count); count++; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (map[i][j] == 1) printf(\"*\"); else printf(\"%d\", danZone[i][j]); &#125; printf(\"\\n\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Cplusplus","slug":"Cplusplus","permalink":"https://kaibaooo.github.io/tags/Cplusplus/"},{"name":"C","slug":"C","permalink":"https://kaibaooo.github.io/tags/C/"}]},{"title":"Javascript展開運算元","slug":"js-spread-operator","date":"2018-10-09T16:00:00.000Z","updated":"2019-07-18T06:23:58.000Z","comments":true,"path":"2018/10/10/js-spread-operator/","link":"","permalink":"https://kaibaooo.github.io/2018/10/10/js-spread-operator/","excerpt":"一般來說，如果要將兩個陣列合併，會用 var arr1 = [1, 2];var arr2 = [3, 4];var arr3 = [arr1, arr2]; 但這樣做出來的arr3結果會是 [ [1, 2], [3 ,4] ] 直接將陣列當成是陣列中的元素，而不是我們想要的 [1, 2, 3, 4] 單純元素存進去就好 所以使用到一個功能 … 沒有錯，就是...","text":"一般來說，如果要將兩個陣列合併，會用 var arr1 = [1, 2];var arr2 = [3, 4];var arr3 = [arr1, arr2]; 但這樣做出來的arr3結果會是 [ [1, 2], [3 ,4] ] 直接將陣列當成是陣列中的元素，而不是我們想要的 [1, 2, 3, 4] 單純元素存進去就好 所以使用到一個功能 … 沒有錯，就是... ...的功能稱為展開，會將陣列的理面的每個元素做回傳，例如 var arr = [1, 2, 3, 4];console.log(...arr);// output// 1// 2// 3// 4 所以如果要將兩個陣列內容元素做合併，可以這樣做 var arr1 = [1, 2];var arr2 = [3, 4];var arr3 = [...arr1, ...arr2]; 輸出結果會是 [1, 2, 3, 4] 而不再是單純將陣列放進去當元素了!","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://kaibaooo.github.io/tags/Javascript/"}]},{"title":"Apache啟用UserDir的方法","slug":"apache-userdir","date":"2018-05-09T16:00:00.000Z","updated":"2019-07-18T06:22:36.000Z","comments":true,"path":"2018/05/10/apache-userdir/","link":"","permalink":"https://kaibaooo.github.io/2018/05/10/apache-userdir/","excerpt":"","text":"UserDIR是什麼?UserDIR是Apache裡的一個模組之一，它可以讓使用者的資料夾都變成一個獨立的網頁環境，方便使用者架設自己的個人網站，使用者的網站會位在http://localhost/~user/ 首先啟用userdir功能 sudo a2enmod userdir 接下來要調整userdir的設定檔userdir.conf sudo vim /etc/apache2/mods-enabled/userdir.conf 將內容更改為如下設定 &lt;IfModule mod_userdir.c&gt; UserDir public_html UserDir disabled root &lt;Directory /home/*/public_html&gt; AllowOverride All Options MultiViews Indexes SymLinksIfOwnerMatch &lt;Limit GET POST OPTIONS&gt; Require all granted &lt;/Limit&gt; &lt;LimitExcept GET POST OPTIONS&gt; Require all denied &lt;/LimitExcept&gt; &lt;/Directory&gt;&lt;/IfModule&gt; 最後重新啟動apache伺服器 sudo service apache2 restart 之後只要使用者有建立public_html資料夾，就能在http://localhost/~user/上顯示出來了","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://kaibaooo.github.io/tags/Linux/"}]}]}